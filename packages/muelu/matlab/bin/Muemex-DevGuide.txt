Muemex - MueLu interface for MATLAB
Developer Features

<><><><><><><><>
Matlab Factories
<><><><><><><><>

-MatlabSmoother, SingleLevelMatlabFactory and TwoLevelMatlabFactory are
implementations of SmootherPrototype, SingleLevelFactoryBase, and
TwoLevelFactoryBase that use matlab functions instead of C++ code
to generate data in MueLu levels.

Parameters: Set in XML parameter list in the factory instantiation.

MatlabSmoother: "Needs", "Setup Function", "Solve Function", "Number of Solver
Args"
-"Needs" is a comma-separated list of hierarchy data that the smoother will
request, and pass into setup function in order that they are listed.
-"Setup Function" is the matlab function to run to set up the smoothing. Must
take a sparse matrix (A) followed by the matlab types corresponding to "Needs"
-"Solve Function" is the matlab function to run the solve phase of the
smoother. Must take sparse matrix A, double array X, double array B, followed by
the outputs of "Setup Function" as arguments. Shouldn't return anything.
-"Number of Solver Args" (int) is the number of expected outputs of "Setup
Function" that will be stored until the solve phase, when they will be
passed in after A, x, b.

SingleLevelMatlabFactory: "Needs", "Provides", "Function"
-"Needs" is list of inputs to the matlab function that will be pulled from
level. "Level" is a special key for the Needs list, and will be passed to MATLAB with the
current level ID.
-"Provides" is what will be returned by the matlab function and added to the
level.
-"Function" is the name of the matlab function to run. Parameters/return
values must match Needs/Provides.

TwoLevelMatlabFactory: "Needs Fine", "Needs Coarse", "Provides", "Function"
-Just like SingleLevelMatlabFactory, but inputs come from both fine and coarse
levels.

<><><><><><><><><>
Custom Variables:
<><><><><><><><><>

Muemex also supports setting custom data in the hierarchy. To use this
feature, set the data you want as a parameter in a level sublist when
setting up the problem. For example, if you want a matrix "MyMatrix" to
be available to a matlab factory, set up with this command:

muelu('setup', A, 'level 0', {'Matrix MyMatrix', MyMatrix}, 'xml parameter
file', 'myXMLParams.xml');

Notice the type specifier "Matrix" before the variable name. This is part
of the name, and has to be included in every mention of the variable. The
type is not case sensitive; 'MultiVector' and 'multivector' are equivalent.
The name itself can be any string without whitespace. Names have to unique
within their level - there can't be "Double d1" and "Int d1".

If an aggregates factory needs that custom matrix, the XML parameter list for
the problem might look like this:
...
<Parameter name="factory" type="string" value="SingleLevelMatlabFactory"/>
<Parameter name="Provides" type="string" value="Aggregates"/>
<Parameter name="Needs" type="string" value="A, Matrix MyMatrix"/>
<Parameter name="Function" type="string" value="simpleAggregation"/>
...

This will send MyMatrix to simpleAggregation as the second argument.
There must always be exactly one space between the
type and the name. Leading and trailing spaces are always ignored.

The following custom variable types are supported:
-Matrix (sparse, MxM, real or complex depending on MueLu context)
-MultiVector
-OrdinalVector (must be Mx1 column vector of int32)
-Int (32 bit signed)
-Scalar (double or complex depending on context)
-Double
-Complex

Note: Custom variables added to the hierarchy either through muelu('setup') or
by a matlab factory are never removed from their level - a UserData keep
flag is set for them.

<><><><><><><><><>
Matlab Callbacks:
<><><><><><><><><>

The "MueLu_MatlabUtils" code contains the backend for the matlab factories.
There is a system for defining inputs and outputs for arbitrary matlab
functions. There are also functions for converting between matlab data types (mxArray*)
and C++/Xpetra data types.

vector<RCP<MuemexArg>> callMatlab(string function, int numOutputs, vector<RCP<MuemexArg>> args);

This function is declared in "MueLu_MatlabUtils_decl.hpp". It calls the matlab function "function",
with "args" as arguments, expecting numOutputs outputs, and returning the list of returned values.
The MuemexArg class is a basic wrapper for the several types of data that can be passed to and from
matlab. It only stores a MUEMEX_TYPE representing the underlying type of the data:

enum MUEMEX_TYPE
{
  INT,
  DOUBLE,
  STRING,
  COMPLEX,
  XPETRA_ORDINAL_VECTOR,
  TPETRA_MULTIVECTOR_DOUBLE,
  TPETRA_MULTIVECTOR_COMPLEX,
  TPETRA_MATRIX_DOUBLE,
  TPETRA_MATRIX_COMPLEX,
  XPETRA_MATRIX_DOUBLE,
  XPETRA_MATRIX_COMPLEX,
  XPETRA_MULTIVECTOR_DOUBLE,
  XPETRA_MULTIVECTOR_COMPLEX,
  EPETRA_CRSMATRIX,
  EPETRA_MULTIVECTOR,
  AGGREGATES,
  AMALGAMATION_INFO
};

class MuemexArg
{
    MuemexArg(MUEMEX_TYPE dataType);
    MUEMEX_TYPE type;
};

MuemexData is a subclass of MuemexArg. It has one the types listed in MUEMEX_TYPE as a field.

template<typename T>
class MuemexData
{
    public:
        MuemexData(T& data);
        MuemexData(const mxArray* mxa);
        mxArray* convertToMatlab();
        T& getData();
    private:
        T data;
};

MuemexData can either be constructed using the actual underlying data object, or an mxArray*. Either
way, the data is copied and stored as a C++/Xpetra object. Note that MuemexData can only be used with Trilinos
types wrapped in Teuchos::RCP. Int, double, string and complex should not be wrapped.

Any RCP<MuemexData<T>> object can be converted to a pure RCP<MuemexArg> with

    RCP<MuemexArg> arg = rcp_implicit_cast<MuemexArg>(mmData);

and back with

    RCP<MuemexData<T>> mmData = rcp_static_cast<MuemexData<T>>(arg);

The type of the underlying MuemexData data is stored in MuemexArg::type.

<><><><><><><><><><><><>
Matlab Callback Example:
<><><><><><><><><><><><>

This matlab function calculates the inverse tangent and also times the calculation.

    function [angle, timeElapsed] = timedAtan(y, x)
        tic;
        angle = atan2(y, x);
        timeElapsed = toc;
    end

To use the function from C++, do:

    double y = 5.423;
    double x = 42.6;
    vector<MuemexArg> inputs;
    inputs.push_back(rcp(new MuemexData<double>(y)));                                      //add the first argument (y)
    inputs.push_back(rcp(new MuemexData<double>(x)));                                      //add the second argument (x)
    /*
      Note that it is not necessary to rcp_implicit_cast the RCP<MuemexData> objects when adding them to MuemexArg vector - this happens implicitly
    */
    vector<MuemexArg> outputs = callMatlab("timedAtan", 2, inputs);                        //call the function, expect 2 outputs
    RCP<MuemexData<double>> angleOutput = rcp_static_cast<MuemexData<double>>(outputs[0]); //recover the outputs, knowing both have type "double"
    RCP<MuemexData<double>> timeOutput = rcp_static_cast<MuemexData<double>>(outputs[1]);
    printf("The arctan of %f/%f is %f, and the calculation took %f seconds.", y, x, angleOutput->getData(), timeOutput->getData());

<><><><><><><><><><><><>
Direct Data Conversion:
<><><><><><><><><><><><>

It is also possible to directly convert between matlab arrays and C++ objects (without using a MuemexData wrapper).
To access a matlab array pointer "mxa" from C++, do:

   int myInt = loadDataFromMatlab<int>(mxa);

To copy a C++ object to matlab, do:

   mxArray* mxa = saveDataToMatlab(data);

The following types are supported by these functions ('Node' is the default Kokkos serial node type):
-int
-double
-std::complex<double>
-std::string
-RCP<Xpetra::Matrix<double, int, int, Node>>
-RCP<Xpetra::Matrix<complex, int, int, Node>>
-RCP<Xpetra::MultiVector<double, int, int, Node>>
-RCP<Xpetra::MultiVector<complex, int, int, Node>>
-RCP<Tpetra::CrsMatrix<double, int, int, Node>>
-RCP<Tpetra::CrsMatrix<complex, int, int, Node>>
-RCP<Tpetra::MultiVector<double, int, int, Node>>
-RCP<Tpetra::MultiVector<complex, int, int, Node>>
-RCP<Epetra_CrsMatrix>
-RCP<Epetra_MultiVector>
-RCP<Xpetra::Vector<int, int, int, Node>>
-RCP<MueLu::Aggregates<int, int, Node>>

Note that the Aggregates structure in matlab must be constructed with the "constructAggregates.m" function:
    function agg = constructAggregates(nVertices, nAggregates, vertexToAggID, rootNodes, aggSizes);

-nVertices:     Total number of nodes in the problem (since all MueMex problems are serial)
-nAggregates:   Total number of aggregates
-vertexToAggID: Array of length nVertices, maps nodes to aggregate IDs
-rootNodes:     Array of length nAggregates, contains node IDs of all the aggregate roots
-aggSizes:      Array of length nAggregates, contains the number of nodes in each aggregate
