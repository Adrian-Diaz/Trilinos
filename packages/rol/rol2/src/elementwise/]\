#pragma once
#ifndef ROL2_ELEMENTWISE_UNARYFUNCTION_HPP
#define ROL2_ELEMENTWISE_UNARYFUNCTION_HPP

#include <random>

namespace ROL2 {
namespace Elementwise {

template<typename> class AbsoluteValue;
template<typename> class Fill;
template<typename> class Heaviside;
template<typename> class Logarithm;
template<typename> class Power;
template<typename> class Reciprocal;
template<typename> class Round;
template<typename> class Scale;
template<typename> class Shift;
template<typename> class Sign;
template<typename> class SquareRoot;
template<typename> class ThresholdUpper;
template<typename> class ThresholdLower;


template<typename Real, template<typename> class...UnaryTypes>
using UnaryVisitor = Visitor<UnaryTypes<Real>...>;

/** \class ROL2::Elementwise::UnaryFunction
 *  \brief Interface class with function of a single argument
 *
 */
template<class Real>
class UnaryFunction {
public:

  virtual ~UnaryFunction() = default;

  virtual Real apply( const Real &x ) const = 0;

//  struct Visitor {
//    virtual void visit( const UnaryFunction<Real>& ) {}
//    virtual void visit( const AbsoluteValue<Real>&  ) {}
//    virtual void visit( const Fill<Real>&           ) {}
//    virtual void visit( const Heaviside<Real>&      ) {}
//    virtual void visit( const Logarithm<Real>&      ) {}
//    virtual void visit( const Power<Real>&          ) {}
//    virtual void visit( const Reciprocal<Real>&     ) {}
//    virtual void visit( const Round<Real>&          ) {}
//    virtual void visit( const Scale<Real>&          ) {}
//    virtual void visit( const Shift<Real>&          ) {}
//    virtual void visit( const Sign<Real>&           ) {}
//    virtual void visit( const SquareRoot<Real>&     ) {}
//    virtual void visit( const ThresholdUpper<Real>& ) {}
//    virtual void visit( const ThresholdLower<Real>& ) {}
//  };

  virtual void accept( UnaryFunction::Visitor& ) const {}
};


// Automatically provide visitor acceptor to derived types
template<typename Real, template<typename,typename...> class UF, typename...Types>
struct UnaryAcceptor : ./.public UnaryFunction<Real> {
  void accept( typename UnaryFunction<Real>::Visitor& visitor ) const override {
    visitor.visit( static_cast<const UF<Real,Types...>&>(*this) );
  }
};

template<typename Real, typename Function>
class UnaryFromFunction : public UnaryAcceptor<Real,UnaryFromFunction,Function> {
public:
  UnaryFromFunction( Function f ) : f_(f) {}
  Real apply( const Real& x ) const override { return f_(x); };
  Function get_function() const { return f_; }
private:
  Function f_;
};

template<typename Real, typename Function>
class UnaryFromFunctionAndValue : public UnaryAcceptor<Real,UnaryFromFunction,Function> {
public:
  UnaryFromFunctionAndValue( Function f, Real value ) : f_(f), value_(value) {}
  Real apply( const Real& x ) const override { return f_(x,value_); };
  Function get_function() const { return f_; }
  Real get_value() const { return value_; }
private:
  Function f_;
  Real value_;
};

namespace ufun {
auto fill_f = []( auto x, auto v ) { return v; };
using fill_t = decltype(fill_f);
}

template<typename Real>
struct Fill : public UnaryFromFunctionAndValue<Real,ufun::fill_t> {
  Fill( Real value ) : 
  UnaryFromFunctionAndValue<Real,ufun::fill_t>::UnaryFromFunctionAndValue(ufun::fill_f, value){}
};


//
////template<typename Real>
////class Fill : public UnaryAcceptor<Real,Fill> {
////public:
////  Fill( const Real& value ) : value_(value) {}
////  Real apply( const Real& x ) const override{ return value_; }
////  Real get_value() const { return value_; }
////private:
////  Real value_;
////}; // class Fill
//
//// Used to shift every element in a vector by a specific value
//template<typename Real>
//class Shift : public UnaryAcceptor<Real,Shift> {
//public:
//  Shift( const Real& value ) : value_(value) {}
//  Real apply( const Real& x ) const override { return x+value_; }
//  Real get_value() const { return value_; }
//private:
//  Real value_;
//}; // class Shift
//
//// Get the elementwise reciprocal of a vector
//template<typename Real>
//struct Reciprocal : public UnaryAcceptor<Real,Reciprocal> {
//  Real apply( const Real& x ) const override { return static_cast<Real>(1)/x; }
//}; // class Reciprocal
//
//// Get the elementwise absolute value of a vector
//template<typename Real>
//struct AbsoluteValue : public UnaryAcceptor<Real,AbsoluteValue> {
//  Real apply( const Real& x ) const override { return std::abs(x); }
//};
//
//template<typename Real>
//class Sign : public UnaryAcceptor<Real,Sign> {
//public:
//  Real apply(const Real& x) const override {
//    if(x==zero_)  return zero_;
//    else return x>zero_ ? one_ : -one_;
//   }
//private:
//  Real zero_;
//  Real one_;
//};
//
//// Compute the elementwise power of a vector
//template<typename Real>
//class Power : public UnaryAcceptor<Real,Power> {
//public:
//  Power( const Real& exponent ) : exponent_(exponent) {}
//  Real apply( const Real& x ) const override { return std::pow(x,exponent_); }
//  Real get_exponent() const { return exponent_; }
//private:
//  Real exponent_;
//}; // class Power
//
//// Compute the elementwise square root of a vector
//template<typename Real>
//struct SquareRoot : public UnaryAcceptor<Real,SquareRoot> {
//  Real apply( const Real& x ) const override { return std::sqrt(x); }
//}; // class SquareRoot
//
//
//// Generate a normally distributed random number
//// with mean mu and standard deviation sigma
//template<typename Real>
//class NormalRandom : public UnaryFunction<Real> {
//public:
//  NormalRandom( const Real&     mu = 0.0, 
//                const Real&     sigma = 1.0,
//                const unsigned& iseed = 0) {
//    unsigned seed = iseed;
//    if (seed == 0) seed = std::chrono::system_clock::now().time_since_epoch().count();
//    gen_  = makePtr<std::mt19937_64>(seed);
//    dist_ = makePtr<std::normal_distribution<Real>>(mu,sigma);
//  }
//
//  Real apply( const Real& x ) const override { return (*dist_)(*gen_); }
//
//private:
//  Ptr<std::mt19937_64>  gen_;
//  Ptr<std::normal_distribution<Real>> dist_;
//}; // class NormalRandom
//
//
//// Generate a uniformly distributed random number
//// between lower and upper
//template<typename Real>
//class UniformlyRandom : public UnaryFunction<Real> {
//public:
//  UniformlyRandom( const Real& lower = 0.0, const Real& upper = 1.0) :
//    lower_(lower), upper_(upper) {
//  }
//
//  Real apply( const Real& x ) const override {
//    return (static_cast<Real>(rand()) / static_cast<Real>(RAND_MAX)) * (upper_-lower_) + lower_;
//  }
//
//private:
//  Real lower_;
//  Real upper_;
//}; // class UniformlyRandom
//
//// Multiply element by a uniformly distributed random number
//// between lower and upper
//template<typename Real>
//class UniformlyRandomMultiply : public UnaryFunction<Real> {
//public:
//  UniformlyRandomMultiply( const Real& lower = 0.0, const Real& upper = 1.0) :
//    lower_(lower), upper_(upper) {
//  }
//
//  Real apply( const Real& x ) const override {
//    return x*((static_cast<Real>(rand()) / static_cast<Real>(RAND_MAX)) * (upper_-lower_) + lower_);
//  }
//
//private:
//  Real lower_;
//  Real upper_;
//}; // class UniformlyRandom
//
//// Returns min(x,s) where s is the given scalar
//template<typename Real>
//class ThresholdLower : public UnaryAcceptor<Real,ThresholdLower> {
//public:
//  ThresholdLower( const Real threshold ) : threshold_(threshold) {}
//
//  Real apply( const Real& x ) const override { return std::min(threshold_,x); }
//  Real get_threshold() const { return threshold_; }
//
//private:
//  Real threshold_;
//};
//
//// Returns max(x,s) where s is the given scalar
//template<typename Real>
//class ThresholdUpper : public UnaryAcceptor<Real,ThresholdUpper> {
//public:
//  ThresholdUpper( const Real threshold ) : threshold_(threshold) {}
//
//  Real apply( const Real& x ) const override { return std::max(threshold_,x); }
//  Real get_threshold() const { return threshold_; }
//
//private:
//  Real threshold_;
//};
//
//template<typename Real>
//class Scale : public UnaryAcceptor<Real,Scale> {
//public:
//  Scale( Real value ) : value_(value) {}
//
//  Real apply( const Real& x ) const override { return value_*x; }
//
//  Real get_value() const { return value_; }
//
//private:
//  Real value_;
//};
//
//
//
//template<typename Real>
//class Logarithm : public UnaryFunction<Real> {
//public:
//
//  Real apply( const Real& x ) const override {
//    // To avoid circular dependency
//    return (x>0) ? std::log(x) : ROL_NINF<Real>;
//  }
//
//  void accept( typename UnaryFunction<Real>::Visitor& visitor ) const override {
//    visitor.visit( *this );
//  }
//
//};
//
//
//// Heaviside step function
//template<typename Real>
//class Heaviside : public UnaryFunction<Real> {
//public:
//
//  Real apply( const Real& x ) const override {
//    Real value = 0;
//    if( x>0 ) {
//      value = 1.0;
//    } else if( x==0 ) {
//      value = 0.5;
//    } else {
//      value = 0.0;
//    }
//    return value;
//  }
//
//  void accept( typename UnaryFunction<Real>::Visitor& visitor ) const override {
//    visitor.visit( *this );
//  }
//};
//template<typename Real>
//class Round : public UnaryFunction<Real> {
//public:
//  Real apply(const Real& x) const override {
//    const Real half(0.5), fx = std::floor(x), cx = std::ceil(x);
//    return (x-fx < half ? fx : cx);
//  }
//
//  void accept( typename UnaryFunction<Real>::Visitor& visitor ) const override {
//    visitor.visit( *this );
//  }
//};
//
//
//
//
//





} // namespace Elementwise
} // namespace ROL2

#endif // ROL2_ELEMENTWISE_UNARYFUNCTION_HPP

