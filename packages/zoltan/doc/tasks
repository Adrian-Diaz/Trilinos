Key:
B - Erik Boman
D - Karen Devine
E - Carter Edwards
H - Bruce Hendrickson
M - Bill Mitchell
S - Matt St John
V - Courtenay Vaughan


0. Software should have the following properties (if possible).
   A. ANSI C
   B. No global variables
   C. No name conflicts (ie. _all_ routines begin with LB_
   D. Consistent memory management w/ leak detection (use smalloc library)
   E. Return error codes
   F. Graceful exits (don't exit in Zoltan)
   G. Allow for deterministic execution

1. (S&D) Write simple driver that we can distribute
   A. Should provide a template for using the code.
   B. Should also simplify testing.

2. Develop automated testing procedure
   A. Need test problems which can be parameterized
       to different sizes & different numbers of processors.
   B. Need routines to check output for consistency.
   C. Ensure that code can be run deterministically.
       Eg. with a compiler flag all randomness is removed.

3. (H&D) Convert documentation to HTML.

4. (M) Devise a portable fortran interface to Zoltan.
   A. Design interface.
   B. Implement for Unix systems.
   C. Figure out how to handle include files.

5. Implement Performance Monitors
   A. Runtime of partitioner.
   B. Amount of data moved (and time to pack/move/unpack it).
   C. Load balance and communication requirements of new decomposition.

6. (V&H) Support Heterogeneity
   A. Finish formalization of model of parallel computer.
      i. Vector of processor speeds.  Partition to match it.
      ii. Vector of memory sizes.  Partition to not exceed it.
      iii. Description of network.  Map well to it.  (less critical)
   B. Devise user interface to describe heterogeneous machine.
   C. Augment existing algorithms to handle heterogeneity.
   D. Insist that new algorithms handle it too.

7. (H) Improve Unstructured Communication Library.
   A. Graceful exit if out of memory.
   B. Use high short ints as message tags.
   C. Extend functionality
      i. Support for objects of varying sizes.
      ii. Limited-memory communication protocol.

8. (H) Change mechanism for setting method parameters.
  
9. Implement Partitioning Algorithms
   A. (S&V) RCB
      i. Modularize to allow reuse of recurring routines.
      ii. Add prefix sum to improve robustness.
      iii. Support heterogeneous computer model.
      iv. Return geometric description.
      v. Write point drop and box drop routines

   B. (S&V) Inertial (after finishing RCB)
      i. Make sure inertial axes consistent on all procs.
      ii. Return (different) geometric description.
      iii. Write (different) point drop and box drop routines.

   C. (M&E) Tree Based partitioners.
      i. Develop Tree-base user interfaces.
      ii. Devise tree data structure.
      iii. Support both quad-/oct-tree and refinement tree.
      iv. Support hybrid approaches.

   D. (E) Space Filling Curves / Oct-tree
      i. Reuse tree ideas from (C)
      ii. Need new routine to construct oct-tree.

   E. (B) Interface to ParMetis
      i. Understand ParMetis graph data structure (probably copy it).
      ii. Develop user interface for graph construction.
      iii. Implement interface to ParMetis.

   F. Interface to Jostle (less important than ParMetis)

   G. (D) Diffusion methods
      i. Decide whether worth doing or to rely on ParMetis


10. Allow incremental construction of graph or tree.
    A. Requires that tree/graph be updated after previous remapping.

11. Tool for Determining Application's New Communication Pattern.
    A. Looks to be application specific.  Implement common cases.

12. Automated algorithm selection & go/no-go decisions.
