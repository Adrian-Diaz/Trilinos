// @HEADER
//
// ***********************************************************************
//
//   Zoltan2: A package of combinatorial algorithms for scientific computing
//                  Copyright 2012 Sandia Corporation
//
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the Corporation nor the names of the
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Questions? Contact Karen Devine      (kddevin@sandia.gov)
//                    Erik Boman        (egboman@sandia.gov)
//                    Siva Rajamanickam (srajama@sandia.gov)
//
// ***********************************************************************
//
// @HEADER
#include <iostream>
#include <fstream>
#include <limits>
#include <vector>
#include <Teuchos_RCP.hpp>
#include <Teuchos_ParameterList.hpp>
#include <Teuchos_CommandLineProcessor.hpp>
#include <Tpetra_CrsMatrix.hpp>
#include <Tpetra_Import.hpp>
#include <Tpetra_Vector.hpp>
#include <MatrixMarket_Tpetra.hpp>
#include <Zoltan2_XpetraCrsMatrixAdapter.hpp>
#include <Zoltan2_TestHelpers.hpp>
#include <Zoltan2_ColoringProblem.hpp>
#include "zoltan_cpp.h"
//#include <cuda_profiler_api.h>
//#include "ReadMatrixFromFile.h"
#include "dist_graph.h"
#include "fast_map.h"
//#include "xtrapulp.h"
#include "io_pp.h"
#include "repart_graph.hpp"
#include "IanGraphAdapter.hpp"

using Teuchos::RCP;

/////////////////////////////////////////////////////////////////////////////
// Program to demonstrate use of Zoltan2 to color a TPetra matrix
// (read from a MatrixMarket file or generated by Galeri::Xpetra).
// We assume the matrix is structurally symmetric.
// Usage:
//     a.out [--inputFile=filename] [--outputFile=outfile] [--verbose]
//           [--x=#] [--y=#] [--z=#] [--matrix={Laplace1D,Laplace2D,Laplace3D}
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Eventually want to use Teuchos unit tests to vary z2TestLO and
// GO.  For now, we set them at compile time based on whether Tpetra
// is built with explicit instantiation on.  (in Zoltan2_TestHelpers.hpp)

typedef zlno_t z2TestLO;
typedef zgno_t z2TestGO;
//typedef uint64_t z2TestLO;
//typedef uint64_t z2TestGO;
typedef zscalar_t z2TestScalar;

typedef Tpetra::CrsMatrix<z2TestScalar, z2TestLO, z2TestGO> SparseMatrix;
typedef SparseMatrix::crs_graph_type CrsGraph;
typedef CrsGraph::map_type map_t;
typedef typename CrsGraph::local_graph_type::row_map_type row_map_t;
typedef typename CrsGraph::local_graph_type::entries_type::non_const_type entries_t;
typedef Tpetra::Vector<z2TestScalar, z2TestLO, z2TestGO> Vector;
typedef Vector::node_type Node;
typedef Tpetra::Import<z2TestLO, z2TestGO> Import;

typedef Zoltan2::XpetraCrsMatrixAdapter<SparseMatrix> SparseMatrixAdapter;
typedef SparseMatrixAdapter::part_t part_t;

//using lno_t = Tpetra::Map<>::local_ordinal_type;
//using gno_t = Tpetra::Map<>::global_ordinal_type;
//using scalar_t = int;
//using myTypes = Zoltan2::BasicUserTypes<scalar_t, lno_t, gno_t>;
using myAdapter = Zoltan2::IanGraphAdapter<Zoltan2::BasicUserTypes<zscalar_t, Tpetra::Map<>::local_ordinal_type, Tpetra::Map<>::global_ordinal_type>>;
extern "C" int get_num_elements(void *data, int *ierr){
  color_dist_graph_t* dist_graph;

  if(data == NULL){
    *ierr = ZOLTAN_FATAL;
    return 0;
  }

  *ierr = ZOLTAN_OK;
  dist_graph = (color_dist_graph_t*) data;
  return dist_graph->n_local;
}

extern "C" void get_elements(void *data, int num_gid_entries, int num_lid_entries,
                                    ZOLTAN_ID_PTR global_id, ZOLTAN_ID_PTR local_id,
                                    int wdim, float *wgt, int *ierr){
  color_dist_graph_t* dist_graph;
  
  if(data == NULL){
    *ierr = ZOLTAN_FATAL;
    return;
  }

  dist_graph = (color_dist_graph_t*) data;
  for(int i = 0; i < dist_graph->n_local; i++){
    global_id[i] = dist_graph->local_unmap[i];
    local_id[i] = i;
  }
  *ierr = ZOLTAN_OK;
}

extern "C" void get_num_edges_list(void *data, int num_gid_entries, int num_lid_entries,
                                          int num_obj, ZOLTAN_ID_PTR global_id, ZOLTAN_ID_PTR local_id,
                                          int *numEdges, int* ierr){
  color_dist_graph_t* dist_graph;
  
  if(data==NULL){
    *ierr = ZOLTAN_FATAL;
     return;
  }
  *ierr = ZOLTAN_OK;
  dist_graph = (color_dist_graph_t*) data;
  for(int i = 0; i < num_obj; i++){
    numEdges[i] = dist_graph->out_offsets[local_id[i]+1] - dist_graph->out_offsets[local_id[i]];
  }
}

extern "C" void get_edge_list(void *data, int num_gid_entries, int num_lid_entries,
                                     int num_obj, ZOLTAN_ID_PTR global_id, ZOLTAN_ID_PTR local_id,
                                     int* num_edges,
                                     ZOLTAN_ID_PTR nbor_global_id, int *nbor_procs,
                                     int get_ewgts, float *nbor_ewgts, int *ierr){
  color_dist_graph_t* dist_graph;

  if(data==NULL){
    *ierr = ZOLTAN_FATAL;
    return;
  }
  
  dist_graph = (color_dist_graph_t*) data;
  nbor_ewgts = NULL;
  uint64_t nbor_idx = 0;
  for(int i = 0; i < num_obj; i++){
    uint64_t lid = local_id[i];
    for(int j = dist_graph->out_offsets[lid]; j < dist_graph->out_offsets[lid+1]; j++){
      uint64_t nbor_lid = dist_graph->out_edges[j];
      if(nbor_lid < dist_graph->n_local){
        nbor_global_id[nbor_idx] = dist_graph->local_unmap[nbor_lid];
        nbor_procs[nbor_idx++] = procid;
      } else {
        nbor_global_id[nbor_idx] = dist_graph->ghost_unmap[nbor_lid - dist_graph->n_local];
        nbor_procs[nbor_idx++] = dist_graph->ghost_tasks[nbor_lid - dist_graph->n_local];
      }
    }
  }
  *ierr = ZOLTAN_OK;
}

int validateColoring(RCP<SparseMatrix> A, int *color)
// returns 0 if coloring is valid, nonzero if invalid
{
  int nconflicts = 0;
  Teuchos::ArrayView<const zlno_t> indices;
  Teuchos::ArrayView<const zscalar_t> values; // Not used

  // Count conflicts in the graph.
  // Loop over local rows, treat local column indices as edges.
  zlno_t n = A->getNodeNumRows();
  for (zlno_t i=0; i<n; i++) {
    A->getLocalRowView(i, indices, values);
    for (zlno_t j=0; j<indices.size(); j++) {
      if ((indices[j]<n) && (indices[j]!=i) && (color[i]==color[indices[j]])){
        nconflicts++;
        //std::cout << "Debug: found conflict (" << i << ", " << indices[j] << ")" << std::endl;
      }
    }
  }

  return nconflicts;
}

int validateDistributedColoring(RCP<SparseMatrix> A, int *color, int rank){
  int nconflicts = 0;
  
  RCP<const SparseMatrix::map_type> rowMap = A->getRowMap();
  RCP<const SparseMatrix::map_type> colMap = A->getColMap();
  Vector R = Vector(rowMap);
  //put the colors in the scalar entries of R.
  for(size_t i = 0; i < A->getNodeNumRows(); i++){
    R.replaceLocalValue(i,color[i]);
  }

  Vector C = Vector(colMap);
  Import imp = Import(rowMap, colMap);
  C.doImport(R, imp, Tpetra::REPLACE);
  
  Teuchos::ArrayView<const zlno_t> indices;
  Teuchos::ArrayView<const zscalar_t> values; // Not used

  // Count conflicts in the graph.
  // Loop over local rows, treat local column indices as edges.
  size_t n = A->getNodeNumRows();
  auto colorData = C.getData();
  for (size_t i=0; i<n; i++) {
    A->getLocalRowView(i, indices, values);
    for (Teuchos_Ordinal j = 0; j < indices.size(); j++) {
      //std::cout<<"Debug: checking for conflict between vertex "<<rowMap->getGlobalElement(i)<<"(colored "<<color[i]<<") and vertex "<<colMap->getGlobalElement(indices[j])<<"(colored "<<colorData[indices[j]]<<")\n";
      if ((indices[j] != i) && (color[i] == colorData[indices[j]])){
	std::cout<<rank<<": Found conflict between vertex "<<rowMap->getGlobalElement(i)<<"(colored "<<color[i]<<") and vertex "<<colMap->getGlobalElement(indices[j])<<"(colored "<<colorData[indices[j]]<<")\n";
        nconflicts++;
      }
    }
  }
  
  return nconflicts;  
}

int validateDistributedDistance2Coloring(const SparseMatrix& A, int *color, int rank){
  int nconflicts = 0;
  
  SparseMatrix S(A);
  SparseMatrix B(A);
  Tpetra::MatrixMatrix::Multiply(A, false, B, false, S);
  
  RCP<const SparseMatrix::map_type> rowMap = S.getRowMap();
  RCP<const SparseMatrix::map_type> colMap = S.getColMap();
  Vector R = Vector(rowMap);
  //put the colors in the scalar entries of R.
  for(size_t i = 0; i < S.getNodeNumRows(); i++){
    R.replaceLocalValue(i,color[i]);
  }

  Vector C = Vector(colMap);
  Import imp = Import(rowMap, colMap);
  C.doImport(R, imp, Tpetra::REPLACE);
  
  Teuchos::ArrayView<const zlno_t> indices;
  Teuchos::ArrayView<const zscalar_t> values; // Not used

  // Count conflicts in the graph.
  // Loop over local rows, treat local column indices as edges.
  size_t n = S.getNodeNumRows();
  auto colorData = C.getData();
  for (size_t i=0; i<n; i++) {
    S.getLocalRowView(i, indices, values);
    for (Teuchos_Ordinal j = 0; j < indices.size(); j++) {
      if ((indices[j] != i) && (color[i] == colorData[indices[j]])){
        nconflicts++;
      }
    }
  }
  
  return nconflicts;  
}

int checkBalance(zlno_t n, int *color)
// Check size of color classes
{
  // Find max color
  int maxColor = 0;
  for (zlno_t i=0; i<n; i++) {
    if (color[i] > maxColor) maxColor = color[i];
  }

  // Compute color class sizes
  Teuchos::Array<int> colorCount(maxColor+1);
  for (zlno_t i=0; i<n; i++) {
    colorCount[color[i]]++;
  }

  // Find min and max, excluding color 0.
  int smallest = 1;
  int largest  = 1;
  zlno_t small = colorCount[1];
  zlno_t large = colorCount[1];
  for (int i=1; i<=maxColor; i++){
    if (colorCount[i] < small){
      small = colorCount[i];
      smallest = i;
    }
    if (colorCount[i] > large){
      large = colorCount[i];
      largest = i;
    }
  }

  return 0;
}

/////////////////////////////////////////////////////////////////////////////
int main(int narg, char** arg)
{
  std::string inputFile = "";            // Matrix Market file to read
  std::string outputFile = "";           // Output file to write
  std::string colorAlg = "SerialGreedy"; // Default algorithm is the serial greedy one.
  bool verbose = false;                  // Verbosity of output
  std::string prepartition = "";         // Call Zoltan2 partitioning to better
                                         // distribute the 
                                         // graph before coloring
  bool prepartition_rows = false;        // When prepartition=rows, 
                                         // balance wrt rows;
  bool prepartition_nonzeros = false;    // When prepartition=nonzeros,
                                         // balance wrt matrix nonzeros.
  int testReturn = 0;
  int totalColors = 0;
  int localColors = 0;

  ////// Establish session.
  Tpetra::ScopeGuard tscope(&narg, &arg);
  Kokkos::print_configuration(std::cout);
  Teuchos::RCP<const Teuchos::Comm<int> > comm = Tpetra::getDefaultComm();
  int me = comm->getRank();

  if (me == 0) std::cout << "Starting everything, size of zlno_t:" <<sizeof(zlno_t)<<" size of zgno_t:"<<sizeof(zgno_t) <<std::endl;
  // Read run-time options.
  Teuchos::CommandLineProcessor cmdp (false, false);
  cmdp.setOption("colorMethod", &colorAlg,
                 "Coloring algorithms supported: SerialGreedy, Hybrid, 2GL, D2");
  cmdp.setOption("inputFile", &inputFile,
                 "Name of a Matrix Market file in the data directory; "
                 "if not specified, a matrix will be generated by Galeri.");
  cmdp.setOption("outputFile", &outputFile,
                 "Name of file to write the coloring");
  cmdp.setOption("verbose", "quiet", &verbose,
                 "Print messages and results.");
  cmdp.setOption("prepartition", &prepartition,
                 "Partition the input graph for better initial distribution;"
                 "valid values are rows and nonzeros");

  //////////////////////////////////
  // Even with cmdp option "true", I get errors for having these
  //   arguments on the command line.  (On redsky build)
  // KDDKDD Should just be warnings, right?  Code should still work with these
  // KDDKDD params in the create-a-matrix file.  Better to have them where
  // KDDKDD they are used.
  int xdim=10;
  int ydim=10;
  int zdim=10;
  std::string matrixType("Laplace3D");

  cmdp.setOption("x", &xdim,
                "number of gridpoints in X dimension for "
                "mesh used to generate matrix.");
  cmdp.setOption("y", &ydim,
                "number of gridpoints in Y dimension for "
                "mesh used to generate matrix.");
  cmdp.setOption("z", &zdim,
                "number of gridpoints in Z dimension for "
                "mesh used to generate matrix.");
  cmdp.setOption("matrix", &matrixType,
                "Matrix type: Laplace1D, Laplace2D, or Laplace3D");

  //////////////////////////////////
  // Coloring options to test.
  //////////////////////////////////
  std::string colorMethod("FirstFit");
  //int balanceColors = 0;
  cmdp.setOption("color_choice", &colorMethod,
       "Color choice method: FirstFit, LeastUsed, Random, RandomFast");
  int batchSize = -1;
  cmdp.setOption("batchSize", &batchSize,
               "Batch Size for distributed coloring. Negative signifies all.");
  std::string kokkosOnlyInterior("false");
  cmdp.setOption("kokkosOnlyInterior", &kokkosOnlyInterior,
               "Sets whether Kokkos colors only interior vertices (true, false)");
  // cmdp.setOption("balance_colors", &balanceColors,
  //                "Balance the size of color classes: 0/1 for false/true");

  //////////////////////////////////
  cmdp.parse(narg, arg);
  if (prepartition != "") {
    if (prepartition == "rows") prepartition_rows = true;
    else if (prepartition == "nonzeros") prepartition_nonzeros = true;
    else {
      std::cout << "Invalid value of prepartition option " << prepartition
                << std::endl;
      std::cout << "No prepartitioning will be done" << std::endl;
      std::cout << "FAIL" << std::endl;
      return -1;
    }
  }

  RCP<UserInputForTests> uinput;
  RCP<SparseMatrix> Matrix;
  RCP<CrsGraph> crs_graph;
  RCP<myAdapter> graph_adapter;
  if(inputFile.find("ebin") != string::npos){//we're dealing with a binary file
    procid = comm->getRank();
    nprocs = comm->getSize();
    graph_gen_data_t* ggi = new graph_gen_data_t;
    //char* filename = new char[inputFile.length()+2];
    //strncpy(filename, inputFile.c_str(),inputFile.length());
    //filename[inputFile.length()+1] = '\0';
    //debug = true;
    printf("--Rank %d: Reading File %s\n",comm->getRank(), inputFile.c_str());
    if(comm->getSize() > 1) load_graph_edges(inputFile.c_str(), ggi);
    else load_graph_edges_threaded(inputFile.c_str(), ggi);
    //delete [] filename;
    if(comm->getSize() > 1) {
      printf("--Rank %d: going to exchange edges\n",comm->getRank());
      exchange_edges(ggi);
    }
    color_dist_graph_t* dist_graph = new color_dist_graph_t;
    printf("--Rank %d: creating graph\n", comm->getRank());
    if(comm->getSize() > 1) {
      create_graph(ggi,dist_graph);
      printf("--Rank %d: relabeling edges\n",comm->getRank());
      relabel_edges(dist_graph);
    } else if (comm->getSize() == 1){
      create_graph_serial(ggi,dist_graph);
    }
    delete ggi;
    if(prepartition_rows||prepartition_nonzeros && comm->getSize() > 1){  
      //xtrapulp partitioning
      printf("--Rank %d: creating XtraPuLP inputs\n",comm->getRank()); 
      int num_parts = nprocs;
      int* parts = new int[dist_graph->n_local];
      
      double vert_balance = 1.1;
      double edge_balance = 1.1;
      int num_weights = 0;
      bool do_lp_init = false;
      bool do_bfs_init = true;
      bool do_repart = false;
      bool do_edge_balance = prepartition_nonzeros;
      bool do_maxcut_min = false;
      bool verbose_output = true;
      int pulp_seed = rand();
  
      Zoltan2::pulp_part_control_t ppc = {vert_balance, edge_balance,
                                 nullptr,0,
                                 do_lp_init, do_bfs_init, do_repart,
                                 do_edge_balance, do_maxcut_min,
                                 verbose_output, pulp_seed};
      uint64_t* sendbuf = new uint64_t[nprocs];
      uint64_t* recvbuf = new uint64_t[nprocs];
      for (int i = 0; i < nprocs; i++)sendbuf[i] = dist_graph->n_local;
      MPI_Alltoall(sendbuf,1,MPI_UNSIGNED_LONG_LONG,recvbuf,1,MPI_UNSIGNED_LONG_LONG,MPI_COMM_WORLD);
      int proc = 0;
      unsigned long* verts_per_rank = new unsigned long[nprocs+1];
      verts_per_rank[0] = 0;
      for(uint64_t i = 1; i < nprocs+1; i ++){
        verts_per_rank[i] = verts_per_rank[i-1] + recvbuf[i-1];
      }
      delete [] sendbuf;
      delete [] recvbuf;

      uint64_t* global_edges = new uint64_t[dist_graph->m_local];
      for(int i = 0; i < dist_graph->m_local; i++){
        if(dist_graph->out_edges[i] < dist_graph->n_local)
          global_edges[i] = dist_graph->local_unmap[dist_graph->out_edges[i]];
        else 
          global_edges[i] = dist_graph->ghost_unmap[dist_graph->out_edges[i]-dist_graph->n_local];
      }
      Zoltan2::dist_graph_t xp_g;
      printf("Creating xtrapulp graph\n");

      Zoltan2::create_xtrapulp_dist_graph(&xp_g, dist_graph->n, dist_graph->m,
        dist_graph->n_local,dist_graph->m_local,
        global_edges, dist_graph->out_offsets, dist_graph->local_unmap, verts_per_rank,
        0, NULL, NULL);
    
      printf("--Rank %d: calling xtrapulp_run\n",comm->getRank());
      Zoltan2::xtrapulp_run(&xp_g, &ppc, parts, num_parts); 
      delete [] global_edges;
      printf("--Rank %d: going to repartition the input graph\n",comm->getRank());
      mpi_data_t* mpi_data = new mpi_data_t;
      color_init_comm_data(mpi_data);
      repart_graph(dist_graph, mpi_data, parts);  
      color_clear_comm_data(mpi_data);  
      if(comm->getSize() > 1){
        relabel_edges(dist_graph);
      }
    }
    graph_adapter = rcp(new myAdapter(dist_graph));
    Tpetra::global_size_t globalVtx = dist_graph->n;
    std::vector<map_t::global_ordinal_type> gids;
    for(int i = 0; i < dist_graph->n_local; i++) {
      gids.push_back(dist_graph->local_unmap[i]);
    }
    //printf("\n");
    Tpetra::global_size_t dummy = Teuchos::OrdinalTraits<Tpetra::global_size_t>::invalid();
    RCP<map_t> rowMap = rcp(new map_t(dummy, Teuchos::arrayViewFromVector(gids), 0, comm));

    for(int i = 0; i < dist_graph->n_total - dist_graph->n_local; i++){
      gids.push_back(dist_graph->ghost_unmap[i]);
    } 
    //printf("--Rank %d: maxGID = %llu minGID = %llu\n",comm->getRank(),maxGID,minGID);
    dummy = Teuchos::OrdinalTraits<Tpetra::global_size_t>::invalid();
    RCP<map_t> colMap = rcp(new map_t(dummy, Teuchos::arrayViewFromVector(gids), 0, comm));
    row_map_t::non_const_type rowPointers = row_map_t::non_const_type("offsets",dist_graph->n_local+1);
    entries_t adjacencies = entries_t("adjs", dist_graph->m_local);
    for(int i = 0; i < dist_graph->n_local+1; i++) rowPointers(i) = dist_graph->out_offsets[i];
    for(int i = 0; i < dist_graph->m_local; i++) {
      adjacencies(i) = dist_graph->out_edges[i];
    }
    crs_graph = rcp(new CrsGraph(rowMap, colMap, rowPointers, adjacencies));
    crs_graph->fillComplete(); 
    Matrix = rcp(new SparseMatrix(crs_graph));
    Matrix->fillComplete();
    if(colorMethod == "Zoltan"){
      int error;
      float version;
      if((error = Zoltan_Initialize(narg,arg,&version)) != ZOLTAN_OK){
        std::cout<<"fatal: Zoltan_Initialize returned error code "<<error<<"\n";
        return 0;
      }
      std::cout<<"Zoltan initialized, version "<<version<<"\n";
      Zoltan_Struct *zz = Zoltan_Create(MPI_COMM_WORLD);
      Zoltan_Set_Param(zz,"DEBUG_LEVEL","1");
      Zoltan_Set_Param(zz,"NUM_GID_ENTRIES","1");
      Zoltan_Set_Param(zz,"NUM_LID_ENTRIES","1");

      Zoltan_Set_Num_Obj_Fn(zz, get_num_elements, dist_graph);
      Zoltan_Set_Obj_List_Fn(zz, get_elements, dist_graph);
      Zoltan_Set_Num_Edges_Multi_Fn(zz, get_num_edges_list, dist_graph);
      Zoltan_Set_Edge_List_Multi_Fn(zz, get_edge_list, dist_graph);
      Zoltan_Set_Param(zz, "COLORING_PROBLEM","DISTANCE-1");
      
      int* colors = new int[dist_graph->n_local];
      ZOLTAN_ID_PTR gids = new unsigned int[dist_graph->n_local];
      for(int i = 0; i < dist_graph->n_local; i++) gids[i] = dist_graph->local_unmap[i];
      Zoltan_Color(zz, 1, dist_graph->n_local, gids, colors);

      int testReturn = validateDistributedColoring(Matrix,colors,me);
      int numGlobalConflicts = 0;
      Teuchos::reduceAll<int,int>(*comm, Teuchos::REDUCE_SUM,1,&testReturn,&numGlobalConflicts);
      if(me == 0 && numGlobalConflicts > 0){
        std::cout<<"FAIL Zoltan returned an invalid coloring\n";
      } else if (me ==0) {
        int local_max_color = 0;
        for(int i = 0; i < dist_graph->n_local;i++){
          if( local_max_color < colors[i]) local_max_color = colors[i];
        } 
        int global_max_color = 0;
        Teuchos::reduceAll<int,int>(*comm, Teuchos::REDUCE_MAX,1,&local_max_color, &global_max_color);
        std::cout<<"PASS, Zoltan used "<<global_max_color<<" colors\n";
      }
      return 0;
    }
    //delete dist_graph;
    //Matrix = readBinaryFile<SparseMatrix>(inputFile,comm,true,false);
  } else { 
    if (inputFile != ""){ // Input file specified; read a matrix
      uinput = rcp(new UserInputForTests(testDataFilePath, inputFile,
                                         comm, true));
      printf("--Rank %d: Successfully read the file\n",comm->getRank());
    }
    else {                 // Let Galeri generate a matrix
      uinput = rcp(new UserInputForTests(xdim, ydim, zdim, matrixType,
                                         comm, true, true));
    }
    Matrix = uinput->getUITpetraCrsMatrix();
  }
  if (me == 0)
    std::cout << "NumRows     = " << Matrix->getGlobalNumRows() << std::endl
         << "NumNonzeros = " << Matrix->getGlobalNumEntries() << std::endl
         << "NumProcs = " << comm->getSize() << std::endl;

  if (prepartition != "" && inputFile.find("ebin") == string::npos) {
    std::cout<<comm->getRank()<<": Starting to pre-partition, creating adapter\n";
    // Compute new partition of matrix
    std::unique_ptr<SparseMatrixAdapter> zadapter;
    if (prepartition_nonzeros) {
      zadapter = std::unique_ptr<SparseMatrixAdapter>(new SparseMatrixAdapter(Matrix, 1));
      zadapter->setRowWeightIsNumberOfNonZeros(0);
    }
    else {
      zadapter = std::unique_ptr<SparseMatrixAdapter>(new SparseMatrixAdapter(Matrix));
    }
    std::cout<<comm->getRank()<<": created adapter, creating PartitioningProblem\n";
    Teuchos::ParameterList zparams;
    zparams.set("algorithm", "pulp");
    zparams.set("imbalance_tolerance", 1.05);
    zparams.set("partitioning_approach", "partition");
    Zoltan2::PartitioningProblem<SparseMatrixAdapter> 
             zproblem(zadapter.get(), &zparams);
    std::cout<<comm->getRank()<<": created PartitioningProblem, starting to solve\n";
    zproblem.solve();
    std::cout<<comm->getRank()<<": solved Partitioning Problem\n";
    // Print partition characteristics before and after
    std::cout<<comm->getRank()<<": applying partition\n";
    typedef Zoltan2::EvaluatePartition<SparseMatrixAdapter> quality_t;
    quality_t evalbef(zadapter.get(), &zparams, comm, NULL);
    if (me == 0) {
      std::cout << "BEFORE PREPARTITION:  Partition statistics:" << std::endl;
      evalbef.printMetrics(std::cout);
    }

    quality_t evalaft(zadapter.get(), &zparams, comm, &zproblem.getSolution());
    if (me == 0) {
      std::cout << "AFTER PREPARTITION:  Partition statistics:" << std::endl;
      evalaft.printMetrics(std::cout);
    }
    std::cout<<comm->getRank()<<": done evaluating, migrating matrix to use new partitioning\n";
    // Migrate matrix to the new partition
    //RCP<SparseMatrix> newMatrix;
    zadapter->applyPartitioningSolution(*Matrix, Matrix,
                                       zproblem.getSolution());
    //std::cout<<comm->getRank()<<": done applying, replacing old matrix with new one\n";
    //Matrix = newMatrix;
    std::cout<<comm->getRank()<<": done replacing, finished partitioning\n";
  }

  

  ////// Specify problem parameters
  std::cout<<comm->getRank()<<": creating params\n";
  Teuchos::ParameterList params;
  params.set("color_choice", colorMethod);
  params.set("color_method", colorAlg);
  params.set("Hybrid_batch_size",batchSize);
  params.set("Kokkos_only_interior",kokkosOnlyInterior);
  std::cout<<comm->getRank()<<": done creating params\n";
  //params.set("balance_colors", balanceColors); // TODO

  ////// Create an input adapter for the Tpetra matrix.
  //std::cout<<comm->getRank()<<": creating SparseMatrixAdapter\n";
  //SparseMatrixAdapter adapter(Matrix);
  //std::cout<<comm->getRank()<<": done creating adapter\n";

  ////// Create and solve ordering problem
  //repeat 5 times
  int repeat = 5;
  for(int i = 0; i < repeat; i++){

    try
    {
    std::cout<<comm->getRank()<<": creating a coloring problem\n";
    Zoltan2::ColoringProblem<myAdapter> problem(&(*graph_adapter), &params);
    std::cout<<comm->getRank()<<": done creating a coloring problem\n";
    if(comm->getRank()==0) std::cout << "Going to color" << std::endl;
    //cudaProfilerStart();
    problem.solve();
    //cudaProfilerStop();
    ////// Basic metric checking of the coloring solution
    size_t checkLength;
    int *checkColoring = nullptr;
    Zoltan2::ColoringSolution<myAdapter> *soln = problem.getSolution();

    if(comm->getRank()==0) std::cout << "Going to get results" << std::endl;
    // Check that the solution is really a coloring
    checkLength = soln->getColorsSize();
    if(checkLength >0){
      checkColoring = soln->getColors();
      /*for(int i = 0; i <checkLength; i++){
        std::cout<<"local vertex "<<i+1<<" is colored "<<checkColoring[i]<<"\n";
      }*/
    }
    
    if (outputFile != "") {
      std::ofstream colorFile;

      // Write coloring to file,
      // each process writes local coloring to a separate file
      //std::string fname = outputFile + "." + me;
      std::stringstream fname;
      fname << outputFile << "." << comm->getSize() << "." << me;
      colorFile.open(fname.str().c_str());
      for (size_t i=0; i<checkLength; i++){
        colorFile << " " << checkColoring[i] << std::endl;
      }
      colorFile.close();
    }
    
    // Print # of colors on each proc.
    //if(checkLength>0) std::cout << "No. of colors on proc " << me << " : " << soln->getNumColors() << std::endl;
    if(checkLength>0){
      localColors = soln->getNumColors();
    }
    
    //colors are guaranteed to overlap, max will discard duplicates
    Teuchos::reduceAll<int,int>(*comm, Teuchos::REDUCE_MAX,1,&localColors,&totalColors);
    
    std::cout << "Going to validate the soln" << std::endl;
    // Verify that checkColoring is a coloring
    if(colorAlg=="D2"){
      testReturn = validateDistributedDistance2Coloring(*Matrix,checkColoring,me);
      //testReturn += validateDistributedColoring(Matrix,checkColoring,me);
    }else if(colorAlg=="2GL" ||colorAlg == "Hybrid"){
      //need to check a distributed coloring
      testReturn = validateDistributedColoring(Matrix, checkColoring, me);
    } else if (checkLength > 0){
      testReturn = validateColoring(Matrix, checkColoring);
    }
      // Check balance (not part of pass/fail for now)
    if(checkLength > 0) checkBalance((zlno_t)checkLength, checkColoring);
    
    } catch (std::exception &e){
        std::cout << "Exception caught in coloring" << std::endl;
        std::cout << e.what() << std::endl;
        std::cout << "FAIL" << std::endl;
        return 0;
    }
    int numGlobalConflicts = 0;
    Teuchos::reduceAll<int,int>(*comm, Teuchos::REDUCE_MAX,1,&testReturn,&numGlobalConflicts);
    if (me == 0) {
      if (numGlobalConflicts > 0) {
        std::cout << "Number of conflicts found = " << numGlobalConflicts
                  << std::endl;
        std::cout << "Solution is not a valid coloring; FAIL" << std::endl;
      }
      else{
        std::cout << "Used " <<totalColors<< " colors\n"; 
        std::cout << "PASS" << std::endl;
      }
    }
  }
}

