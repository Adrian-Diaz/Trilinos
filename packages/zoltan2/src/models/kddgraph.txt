// @HEADER
//
// ***********************************************************************
//
//   Zoltan2: A package of combinatorial algorithms for scientific computing
//                  Copyright 2012 Sandia Corporation
//
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the Corporation nor the names of the
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Questions? Contact Karen Devine      (kddevin@sandia.gov)
//                    Erik Boman        (egboman@sandia.gov)
//                    Siva Rajamanickam (srajama@sandia.gov)
//
// ***********************************************************************
//
// @HEADER

/*! \file Zoltan2_GraphModel.hpp
    \brief Defines the GraphModel interface.
*/

#ifndef _ZOLTAN2_GRAPHMODEL_HPP_
#define _ZOLTAN2_GRAPHMODEL_HPP_

#include <Zoltan2_Model.hpp>
#include <Zoltan2_ModelHelpers.hpp>
#include <Zoltan2_InputTraits.hpp>
#include <Zoltan2_MatrixAdapter.hpp>
#include <Zoltan2_GraphAdapter.hpp>
#include <Zoltan2_IdentifierAdapter.hpp>
#include <Zoltan2_VectorAdapter.hpp>
#include <Zoltan2_MeshAdapter.hpp>
#include <Zoltan2_StridedData.hpp>

namespace Zoltan2 {

//////////////////////////////////////////////////////////////////////////
/*!  \brief GraphModel defines the interface required for graph models.

    The constructor of the GraphModel can be a global call, requiring
    all processes in the application to call it.  The rest of the
    methods should be local methods.

    The template parameter is an InputAdapter, which is an object that
    provides a uniform interface for models to the user's input data.

    GraphModels may represent a local (on-process) graph or 
    a global (all-communicator) graph.
*/
template <typename Adapter>
class GraphModel : public Model<Adapter>
{
public:

#ifndef DOXYGEN_SHOULD_SKIP_THIS
  typedef typename Adapter::scalar_t    scalar_t;
  typedef typename Adapter::gno_t       gno_t;
  typedef typename Adapter::lno_t       lno_t;
  typedef typename Adapter::node_t      node_t;
  typedef typename Adapter::user_t      user_t;
  typedef typename Adapter::userCoord_t userCoord_t;
  typedef StridedData<lno_t, scalar_t>  input_t;
#endif

  //!  Destructor
  ~GraphModel() { }

  /*! \brief Constructor
   *
   *  \param  inputAdapter  a pointer to the user's data
   *  \param  env           object containing the parameters
   *  \param  comm          communicator for the problem
   *  \param  modelFlags    a bit map of Zoltan2::GraphModelFlags
   *
   *  All processes in the communicator must call the constructor.
   *  \todo document the model flags that might be set
   */

  GraphModel(const RCP<const MatrixAdapter<user_t,userCoord_t> > &ia,
    const RCP<const Environment> &env, const RCP<const Comm<int> > &comm,
    modelFlag_t &modelFlags);

  GraphModel(const RCP<const GraphAdapter<user_t,userCoord_t> > &ia,
    const RCP<const Environment> &env, const RCP<const Comm<int> > &comm,
    modelFlag_t &modelFlags);

  GraphModel(const RCP<const MeshAdapter<user_t> > &ia,
    const RCP<const Environment> &env, const RCP<const Comm<int> > &comm,
    modelFlag_t &modelflags);

  GraphModel(const RCP<const VectorAdapter<userCoord_t> > &ia,
    const RCP<const Environment> &env, const RCP<const Comm<int> > &comm,
    modelFlag_t &flags)
  {
    throw std::runtime_error("cannot build GraphModel from VectorAdapter");
  }

  GraphModel(const RCP<const IdentifierAdapter<user_t> > &ia,
    const RCP<const Environment> &env, const RCP<const Comm<int> > &comm,
    modelFlag_t &flags)
  {
    throw std::runtime_error("cannot build GraphModel from IdentifierAdapter");
  }

  /*! \brief Return the communicator used by the model
   */
  const RCP<const Comm<int> > getComm() { return comm_; }

  /*! \brief Returns the number vertices on this process.
   */
  size_t getLocalNumVertices() const { return numLocalVertices_; }

  /*! \brief Returns the global number vertices.
   */
  size_t getGlobalNumVertices() const { return numGlobalVertices_; }

  /*! \brief Returns the number of global edges on this process.
   *  Includes remote edges.
   *  TODO:  RENAME THIS FUNCTION; THIS NAME IS RIDICULOUS
   */
  size_t getLocalNumGlobalEdges() const { return numLocalEdges_; }

  /*! \brief Returns the number of local edges on this process.
   *  Does not include edges to off-process vertices.
   *  TODO:  THIS FUNCTION SHOULD GO AWAY
   */
  size_t getLocalNumLocalEdges() const {
    if (!localGraph_) { 
      std::cout << "SHOULD NOT BE CALLING THIS getLocalNumLocalEdges "
                   "with global graph" << std::endl;
      abort(-1);
    }
    return numLocalEdges_; 
  }

  /*! \brief Returns the global number edges.
   */
  size_t getGlobalNumEdges() const { return numGlobalEdges_; }

  /*! \brief Returns the number (0 or greater) of weights per vertex
   */
  int getNumWeightsPerVertex() const { return numWeightsPerVertex_; }

  /*! \brief Returns the number (0 or greater) of weights per edge.
   */
  int getNumWeightsPerEdge() const { return nWeightsPerEdge_; }

  /*! \brief Returns the dimension (0 to 3) of vertex coordinates.
   */
  int getCoordinateDim() const { return vCoordDim_; }

  /*! \brief Sets pointers to this process' vertex Ids and their weights.

      \param Ids will on return point to the list of the global Ids for
        each vertex on this process.
      \param xyz If vertex coordinate data is available, \c xyz
         will on return point to a StridedData object of coordinates.
      \param wgts If vertex weights is available, \c wgts
         will on return point to a StridedData object of weights.
   */

  size_t getVertexList(
    ArrayView<const gno_t> &Ids,
    ArrayView<input_t> &xyz,
    ArrayView<input_t> &wgts) const
  {
    Ids = vGids_.view(0, numLocalVertices_);
    xyz = vCoords_.view(0, vCoordDim_);
    wgts = vWeights_.view(0, numWeightsPerVertex_);
    return numLocalVertices_;
  }

  /*! \brief Sets pointers to this process' edge (neighbor) global Ids,
      including off-process edges.

      \param edgeIds This is the list of global neighbor Ids corresponding
        to the vertices listed in getVertexList.
      \param procIds lists the process owning each neighbor in the edgeIds
         list.
      \param offsets offsets[i] is the offset into edgeIds to the start
        of neighbors for ith vertex.
      \param wgts If edge weights is available, \c wgts
         will on return point to a StridedData object of weights.
       \return The number of ids in the edgeIds list.
   */
  // Implied Vertex LNOs from getVertexList are used as indices to offsets
  // array.
  // Vertex GNOs are returned as neighbors in edgeIds.

  size_t getEdgeList( ArrayView<const gno_t> &edgeIds,
    ArrayView<const int> &procIds, ArrayView<const lno_t> &offsets,
    ArrayView<input_t> &wgts) const
  {
    edgeIds = eGids_.view(0, numLocalEdges_);
    procIds = ArrayView<int>();
    offsets = eOffsets_.view(0, numLocalVertices_+1);
    wgts = eWeights_.view(0, nWeightsPerEdge_);
    return numLocalEdges_;
  }

  /*! \brief Sets pointers to this process' local-only edge (neighbor) LNOs,
      using the same implied vertex LNOs returned in getVertexList.

      Local only means the neighbor vertex is owned by this process.

      \param edgeIds lists the only neighbors of the vertices in getVertexList
        which are on this process.  The Id returned is not the neighbor's
        global Id, but rather the index of the neighbor in the list
        returned by getVertexList.
      \param offsets offsets[i] is the offset into edgeIds to the start
        of neighbors for ith vertex returned in getVertexList.
      \param wgts If edge weights is available, \c wgts
         will on return point to a StridedData object of weights.
       \return The number of ids in the edgeIds list.

       This method is not const, because a local edge list is not created
       unless this method is called.

       Note that if there are no local edges, the
         \c edgeIds, \c offsets and \c wgts are returned
         as empty arrays.
   */

  // TODO:  REMOVE THIS FUNCTION
  size_t getLocalEdgeList(
    ArrayView<const lno_t> &edgeIds,
    ArrayView<const lno_t> &offsets,
    ArrayView<input_t> &wgts)
  {
    if (!localGraph) {
      std::cout << "SHOULD NOT BE CALLING getLocalEdgeList "
                   "with global graph" << std::endl;
      abort(-1);
    }
    return getEdgeList(edgeIds, offsets, wgts);
  }

  ////////////////////////////////////////////////////
  // The Model interface.
  ////////////////////////////////////////////////////

  size_t getLocalNumObjects() const { return numLocalVertices_; }

  size_t getGlobalNumObjects() const { return numGlobalVertices_; }

private:

  void shared_constructor(const RCP<const Adapter>&ia, modelFlag_t &modelFlags);

  template <typename AdapterWithCoords>
  void shared_GetVertexCoords(const AdapterWithCoords *ia);

  void print(); // For debugging

  const RCP<const Environment > env_;
  const RCP<const Comm<int> > comm_;

  bool localGraph_;    // Flag indicating whether this graph is 
                       // LOCAL with respect to the process;
                       // if !localGraph_, graph is GLOBAL with respect to
                       // the communicator.
                       

  size_t adapterNumLocalVertices_;         // # local vertices from adapter
  ArrayRCP<const gno_t> adapterVGids_;     // vertices of graph from adapter

  size_t numLocalVertices_;                // # local vertices in built graph
  size_t numGlobalVertices_;               // # global vertices in built graph
  ArrayRCP<gno_t> vGids_;                  // vertices of graph built in model;
                                           // may be same as adapterVGids_,
                                           // or may be renumbered 0 to (N-1).

  int numWeightsPerVertex_;
  ArrayRCP<input_t> vWeights_;

  int vCoordDim_;
  ArrayRCP<input_t> vCoords_;

  // Note: in some cases, size of these arrays
  // may be larger than numLocalEdges_.  So do not use .size().
  // Use numLocalEdges_, numGlobalEdges_

  size_t adapterNumLocalEdges_;           // # local edges from adapter
  ArrayRCP<const gno_t> adapterEGids_;    // edges of graph from adapter
  ArrayRCP<const lno_t> adapterEOffsets_; // edge offsets from adapter

  size_t numLocalEdges_;                  // # local edges in built graph
  size_t numGlobalEdges_;                 // # global edges in built graph
  ArrayRCP<gno_t> eGids_;                 // edges of graph built in model
  ArrayRCP<lno_t> eOffsets_;              // edge offsets build in model
                                          // May be same as adapterEGids_ & 
                                          // adapterEOffsets_, or may differ
                                          // due to renumbering, self-edge
                                          // removal, or local graph.

  int nWeightsPerEdge_;
  ArrayRCP<input_t> eWeights_;

};


////////////////////////////////////////////////////////////////
// GraphModel from MatrixAdapter
template <typename Adapter>
GraphModel<Adapter>::GraphModel(
  const RCP<const MatrixAdapter<user_t,userCoord_t> > &ia,
  const RCP<const Environment> &env,
  const RCP<const Comm<int> > &comm,
  modelFlag_t &modelFlags):
        env_(env),
        comm_(comm),
        localGraph_(false),
        adapterNumLocalVertices_(0),
        adapterVGids_(),
        numLocalVertices_(0),
        numGlobalVertices_(0),
        vGids_(),
        numWeightsPerVertex_(0),
        vWeights_(),
        vCoordDim_(0),
        vCoords_(),
        adapterNumLocalEdges_(0),
        adapterEGids_(),
        adapterEOffsets_(),
        numLocalEdges_(0),
        numGlobalEdges_(0),
        eGids_(),
        eOffsets_(),
        nWeightsPerEdge_(0),
        eWeights_()
{
  // Model creation flags
  localGraph_ = modelFlags.test(BUILD_LOCAL_GRAPH);

  bool symTranspose = modelFlags.test(SYMMETRIZE_INPUT_TRANSPOSE);
  bool symBipartite = modelFlags.test(SYMMETRIZE_INPUT_BIPARTITE);
  bool vertexCols = modelFlags.test(VERTICES_ARE_MATRIX_COLUMNS);
  bool vertexNz = modelFlags.test(VERTICES_ARE_MATRIX_NONZEROS);

  if (symTranspose || symBipartite || vertexCols || vertexNz){
    throw std::runtime_error("graph build option not yet implemented");
  }

  // Get the matrix from the input adapter
  gno_t const *vtxIds=NULL, *nborIds=NULL;
  lno_t const *offsets=NULL;
  try{
    adapterNumLocalVertices_ = ia->getLocalNumIDs();
    ia->getIDsView(vtxIds);
  }
  Z2_FORWARD_EXCEPTIONS;
  try{
    if (ia->CRSViewAvailable()) {
      ia->getCRSView(offsets, nborIds);
    }
    else {
      // TODO:  Add support for CCS matrix layout
      throw std::runtime_error("Only MatrixAdapter::getCRSView is supported "
                               "in graph model");
    }
  }
  Z2_FORWARD_EXCEPTIONS;

  // Save the pointers from the input adapter
  adapterNumLocalEdges_ = offsets[adapterNumLocalVertices_];
  adapterVGids_ = arcp<const gno_t>(vtxIds, 0, adapterNumLocalVertices_, false);
  adapterEGids_ = arcp<const gno_t>(nborIds, 0, adapterNumLocalEdges_, false);
  adapterEOffsets_ = arcp<const lno_t>(offsets, 0, adapterNumLocalVertices_ + 1, false);

  // Edge weights
  nWeightsPerEdge_ = 0;   // no edge weights from a matrix yet.
                          // TODO:  use matrix values as edge weights

  // Do constructor common to all adapters
  shared_constructor(ia, modelFlags);

  // Get vertex coordinates, if available
  if (ia->coordinatesAvailable()) {
    typedef VectorAdapter<userCoord_t> adapterWithCoords_t;
    shared_GetVertexCoords<adapterWithCoords_t>(ia->getCoordinateInput());
  }
  //print();
}


////////////////////////////////////////////////////////////////
// GraphModel from GraphAdapter
template <typename Adapter>
GraphModel<Adapter>::GraphModel(
  const RCP<const GraphAdapter<user_t,userCoord_t> > &ia,
  const RCP<const Environment> &env,
  const RCP<const Comm<int> > &comm,
  modelFlag_t &modelFlags):
        env_(env),
        comm_(comm),
        localGraph_(false),
        adapterNumLocalVertices_(0),
        adapterVGids_(),
        numLocalVertices_(0),
        numGlobalVertices_(0),
        vGids_(),
        numWeightsPerVertex_(0),
        vWeights_(),
        vCoordDim_(0),
        vCoords_(),
        adapterNumLocalEdges_(0),
        adapterEGids_(),
        adapterEOffsets_(),
        numLocalEdges_(0),
        numGlobalEdges_(0),
        eGids_(),
        eOffsets_(),
        nWeightsPerEdge_(0),
        eWeights_()
{
  // Model creation flags
  localGraph_ = modelFlags.test(BUILD_LOCAL_GRAPH);

  // This GraphModel is built with vertices == GRAPH_VERTEX from GraphAdapter.
  // It is not ready to use vertices == GRAPH_EDGE from GraphAdapter.
  env_->localInputAssertion(__FILE__, __LINE__,
    "GraphModel from GraphAdapter is implemented only for "
    "Graph Vertices as primary object, not for Graph Edges",
    ia->getPrimaryEntityType() == Zoltan2::GRAPH_VERTEX, BASIC_ASSERTION);

  // Get the graph from the input adapter

  gno_t const *vtxIds=NULL, *nborIds=NULL;
  lno_t const *offsets=NULL;
  try{
    adapterNumLocalVertices_ = ia->getLocalNumVertices();
    ia->getVertexIDsView(vtxIds);
    ia->getEdgesView(offsets, nborIds);
  }
  Z2_FORWARD_EXCEPTIONS;

  // Save the pointers from the input adapter
  adapterNumLocalEdges_ = offsets[adapterNumLocalVertices_];
  gids_ = arcp<const gno_t>(vtxIds, 0, adapterNumLocalVertices_, false);
  edgeGids_ = arcp<const gno_t>(nborIds, 0, adapterNumLocalEdges_, false);
  offsets_ = arcp<const lno_t>(offsets, 0, adapterNumLocalVertices_ + 1, false);

  // Edge weights
  nWeightsPerEdge_ = ia->getNumWeightsPerEdge();
  if (nWeightsPerEdge_ > 0){
    input_t *wgts = new input_t [nWeightsPerEdge_];
    eWeights_ = arcp(wgts, 0, nWeightsPerEdge_, true);
  }

  for (int w=0; w < nWeightsPerEdge_; w++){
    const scalar_t *ewgts=NULL;
    int stride=0;

    ia->getEdgeWeightsView(ewgts, stride, w);

    ArrayRCP<const scalar_t> wgtArray(ewgts, 0, adapterNumLocalEdges_, false);
    eWeights_[w] = input_t(wgtArray, stride);
  }

  // Do constructor common to all adapters
  shared_constructor(ia, modelFlags);

  // Get vertex coordinates, if available
  if (ia->coordinatesAvailable()) {
    typedef VectorAdapter<userCoord_t> adapterWithCoords_t;
    shared_GetVertexCoords<adapterWithCoords_t>(ia->getCoordinateInput());
  }
  //print();
}

////////////////////////////////////////////////////////////////
// GraphModel from MeshAdapter
template <typename Adapter>
GraphModel<Adapter>::GraphModel(
  const RCP<const MeshAdapter<user_t> > &ia,
  const RCP<const Environment> &env,
  const RCP<const Comm<int> > &comm,
  modelFlag_t &modelFlags):
        env_(env),
        comm_(comm),
        localGraph_(false),
        adapterNumLocalVertices_(0),
        adapterVGids_(),
        numLocalVertices_(0),
        numGlobalVertices_(0),
        vGids_(),
        numWeightsPerVertex_(0),
        vWeights_(),
        vCoordDim_(0),
        vCoords_(),
        adapterNumLocalEdges_(0),
        adapterEGids_(),
        adapterEOffsets_(),
        numLocalEdges_(0),
        numGlobalEdges_(0),
        eGids_(),
        eOffsets_(),
        nWeightsPerEdge_(0),
        eWeights_()
{
  env_->timerStart(MACRO_TIMERS, "GraphModel constructed from MeshAdapter");

  // Model creation flags
  localGraph_ = modelFlags.test(BUILD_LOCAL_GRAPH);

  // This GraphModel is built with vertices == ia->getPrimaryEntityType()
  // from MeshAdapter.

  // Get the graph from the input adapter

  Zoltan2::MeshEntityType primaryEType = ia->getPrimaryEntityType();
  Zoltan2::MeshEntityType secondAdjEType = ia->getSecondAdjacencyEntityType();

  // Get the IDs of the primary entity type; these are graph vertices

  gno_t const *vtxIds=NULL;
  try {
    adapterNumLocalVertices_ = ia->getLocalNumOf(primaryEType);
    ia->getIDsViewOf(primaryEType, vtxIds);
  }
  Z2_FORWARD_EXCEPTIONS;

  gids_ = arcp<const gno_t>(vtxIds, 0, adapterNumLocalVertices_, false);

  // Get the second adjacencies to construct edges of the dual graph.
  gno_t const *nborIds=NULL;
  lno_t const *offsets=NULL;

  if (!ia->avail2ndAdjs(primaryEType, secondAdjEType)) {
    // KDDKDD TODO Want to do this differently for local and global graphs
    // KDDKDD TODO Want to do this differently for local and global graphs
    // KDDKDD TODO Want to do this differently for local and global graphs
    // KDDKDD TODO Want to do this differently for local and global graphs
    // KDDKDD TODO Want to do this differently for local and global graphs
    // KDDKDD TODO Does it suffice to pass a serial comm for local graph?
    try {
      get2ndAdjsViewFromAdjs(ia, comm_, primaryEType, secondAdjEType, offsets,
                             nborIds);
    }
    Z2_FORWARD_EXCEPTIONS;
  }
  else {  // avail2ndAdjs
    // Get the edges
    try {
      ia->get2ndAdjsView(primaryEType, secondAdjEType, offsets, nborIds);
    }
    Z2_FORWARD_EXCEPTIONS;
  }

  // Save the pointers from the input adapter
  adapterNumLocalEdges_ = offsets[adapterNumLocalVertices_];
  edgeGids_ = arcp<const gid_t>(nborIds, 0, adapterNumLocalEdges_, false);
  offsets_ = arcp<const lno_t>(offsets, 0, adapterNumLocalVertices_ + 1, false);

  // Edge weights
  // Cannot specify edge weights if Zoltan2 computes the second adjacencies;
  // there's no way to know the correct order for the adjacencies and weights.
  // InputAdapter must provide 2nd adjs in order for edge weights to be used.
  if (ia->avail2ndAdjs(primaryEType, secondAdjEType)) {
    nWeightsPerEdge_ = ia->getNumWeightsPer2ndAdj(primaryEType, secondAdjEType);
    if (nWeightsPerEdge_ > 0){
      input_t *wgts = new input_t [nWeightsPerEdge_];
      eWeights_ = arcp(wgts, 0, nWeightsPerEdge_, true);
    }

    for (int w=0; w < nWeightsPerEdge_; w++){
      const scalar_t *ewgts=NULL;
      int stride=0;

      ia->get2ndAdjWeightsView(primaryEType, secondAdjEType,
                               ewgts, stride, w);

      ArrayRCP<const scalar_t> wgtArray(ewgts, 0, 
                                        adapterNumLocalEdges_*stride, false);
      eWeights_[w] = input_t(wgtArray, stride);
    }
  }

  // Do constructor common to all adapters
  shared_constructor(ia, modelFlags);

  // Get vertex coordinates
  typedef MeshAdapter<user_t> adapterWithCoords_t;
  shared_GetVertexCoords<adapterWithCoords_t>(&(*ia));

  env_->timerStop(MACRO_TIMERS, "GraphModel constructed from MeshAdapter");
  //print();
}


//////////////////////////////////////////////////////////////////////////
template <typename Adapter>
void GraphModel<Adapter>::shared_constructor(
  const RCP<const Adapter> &ia,
  modelFlag_t &modelFlags)
{
  // Model creation flags
  bool consecutiveIdsRequired = modelFlags.test(USE_GLOBALLY_CONSECUTIVE_IDS);
  bool removeSelfEdges = modelFlags.test(REMOVE_SELF_EDGES);
  bool subsetGraph = modelFlags.test(GRAPH_IS_A_SUBSET_GRAPH);

  if (!localGraph_ && !consecutiveIdsRequired && 
      !removeSelfEdges && !subsetGraph) {
    // If no reason to change graph from input adapter, just copy the pointers

    numLocalVertices_ = adapterNumLocalVertices_;
    vGids_ = arcp_const_cast<gno_t> adapterVGids_;

    numLocalEdges_ = adapterNumLocalEdges_;
    eGids_ = arcp_const_cast<gno_t> adapterEGids_;
    eOffsets_ = arcp_const_cast<gno_t> adapterEOffsets_;
// TODO EDGE WEIGHTS

    // TODO:  ARE THERE OTHERS??
  }

  else if (localGraph_) {
    // Local graph is requrested.
    // Renumber vertices 0 to numLocalVertices_-1
    // Filter out off-process edges
    // Renumber edge neighbors to be in range [0,numLocalVertices_-1]

    numLocalVertices_ = adapterNumLocalVertices_;  // keep all vertices

    // Build map between global and local vertex numbers
    std::unordered_map<gno_t, lno_t> globalToLocal(numLocalVertices_);
    for (size_t i = 0; i < numLocalVertices_; i++)
      globalToLocal[gids_[i]] = i;

    // Allocate new space for local graph info
    // Note that eGids_ may be larger than needed; would have to pre-count 
    // number of local edges otherwise
    vGids_ = arcp(new gno_t[numLocalVertices_],
                  0, numLocalVertices_, true);
    eGids_ = arcp(new gno_t[adapterNumLocalEdges_],
                  0, adapterNumLocalEdges_, true);  
    eOffsets_ = arcp(new lno_t[numLocalVertices_+1],
                     0, numLocalVertices_+1, true);

    eOffsets_[0] = 0;
    lno_t ecnt = 0;
    for (size_t i = 0; i < numLocalVertices_; i++) {
      for (lno_t j = adapterEOffsets[i]; j < adapterEOffsets[i+1]; j++) {
        if ((lno_t localidx = globalToLocal.find(adapterEGids[j])) != 
                              globalToLocal.end()) {
          // neighbor vertex is local

          if (removeSelfEdges && (localidx == i))  
            continue;  // Skipping self edge

          // Keep the edge
          eGids_[ecnt] = localidx
// TODO EDGE WEIGHTS
          ecnt++;
        }  
      }
      eOffsets_[i+1] = ecnt;
    }
    numLocalEdges_ = eOffsets_[numLocalVertices_];
  }

  else { 
    // Build a Global graph
    // If we are here, we expect SOMETHING in the graph to change from input:
    // removing self edges, or converting to consecutive IDs, or subsetting
    // the graph.


    // Determine vertex GIDs for the global GraphModel
    Teuchos::ArrayRCP<size_t> vtxDist; // TODO keep vtxDist & add to interface?

    numLocalVertices_ = adapterNumLocalVertices_;
    if (!consecutiveIdsRequired) 
      vGids_ = arcp_const_cast<gno_t>(adapterVGids_);
    else  {
      // Allocate new memory for vertices for consecutiveIds
      vGids_ = arcp(new gno_t[numLocalVertices_], 0, numLocalVertices_, true);

      // Build vtxDist array with starting vGid on each rank
      int np = comm_->getSize();
      vtxDist = arcp(new size_t[np+1], 0, np+1, true);
      vtxDist[0] = 0;
      Teuchos::Comm::gatherAll(*comm_, 1, &numLocalVertices_, 1, &vtxDist[1]);
      for (int i = 0; i < np; i++)
        vtxDist[i+1] += vtxdist[i];
    }

    // Allocate new memory for edges and offsets, as needed
    // Note that eGids_ may or may not be larger than needed; 
    // would have to pre-count number of edges kept otherwise
    eGids_ = arcp(new gno_t[adapterNumLocalEdges_],
                  0, adapterNumLocalEdges_, true);

    if (!subsetGraph && !removeSelfEdges) 
      // Not changing number of edges and, thus, the offsets
      // Probably only relabeling to consecutive IDs
      eOffsets_ = arcp_const_cast<lno_t>(adapterEOffsets);
    else 
      eOffsets_ = arcp(new lno_t[numLocalVertices_+1],
                       0, numLocalVertices_+1, true);


    // If needed, determine the owning ranks and its local index off-proc
    Teuchos::ArrayRCP<int> edgeRemoteRanks;
    Teuchos::ArrayRCP<lno_t> edgeRemoteLids;

    if (subsetGraph || consecutiveIDsRequired) {
      gno_t dummy = Teuchos::OrdinalTraits<gno_t>::invalid();
      Tpetra::Map<lno_t,gno_t> vtxMap(dummy, adapterVGids_, 0, comm_);

      edgeRemoteRanks = arcp(new int[adapterNumLocalEdges_],
                             0, adapterNumLocalEdges_, true);
      edgeRemoteLids = arcp(new lno_t[adapterNumLocalEdges_],
                            0, adapterNumLocalEdges_, true);
      vtxMap.getRemoteIndexList(adapterEGids_, edgeRemoteRanks, edgeRemoteLids);
    }

    // Renumber and/or filter the edges
    lno_t ecnt = 0;
    for (size_t i = 0; i < numLocalVertices_; i++) {
      for (size_t j = adapterEOffsets_[i]; j < adapterEOffsets_[i+1]; j++) {

        if (removeSelfEdges && (adapterVGids_[i] == adapterEGids_[j]))
          continue;  // Skipping self edge

        if (subsetGraph && (edgeRemoteRanks[j] == -1)) 
          continue;  // Skipping edge with neighbor vertex that was not found 
                     // in communicator

        if (consecutiveIDsRequired)
          // Renumber edge using local number on remote rank plus first 
          // vtx number for remote rank
          eGids_[ecnt] = edgeRemoteLids[j] + vtxDist[edgeRemoteRanks[j]];  
        else
          eGids_[ecnt] = adapterEGids_[j];
// TODO EDGE WEIGHTS:  DON'T NEED TO COPY THEM IF ONLY RENUMBERING
        ecnt++;
      }
    }
    numLocalEdges = ecnt;
  }

  numGlobalVertices_= REDUCEALL(numLocalVertices_);
  numGlobalEdges_ = REDUCEALL(numLocalEdges_);

  // Vertex weights
  numWeightsPerVertex_ = ia->getNumWeightsPerID();

  if (numWeightsPerVertex_ > 0){
    input_t *weightInfo = new input_t [numWeightsPerVertex_];
    env_->localMemoryAssertion(__FILE__, __LINE__, numWeightsPerVertex_,
                               weightInfo);

    for (int idx=0; idx < numWeightsPerVertex_; idx++){
      bool useNumNZ = ia->useDegreeAsWeight(idx);
      if (useNumNZ){
        scalar_t *wgts = new scalar_t [numLocalVertices_];
        env_->localMemoryAssertion(__FILE__, __LINE__, numLocalVertices_, wgts);
        ArrayRCP<const scalar_t> wgtArray = arcp(wgts,
                                                 0, numLocalVertices_, true);
        for (size_t i=0; i < numLocalVertices_; i++)
          wgts[i] = eOffsets_[i+1] - eOffsets_[i];
        weightInfo[idx] = input_t(wgtArray, 1);
      }
      else{
        const scalar_t *weights=NULL;
        int stride=0;
        ia->getWeightsView(weights, stride, idx);
        ArrayRCP<const scalar_t> wgtArray = arcp(weights, 0,
                                                 stride*numLocalVertices_,
                                                 false);
        weightInfo[idx] = input_t(wgtArray, stride);
      }
    }

    vWeights_ = arcp<input_t>(weightInfo, 0, numWeightsPerVertex_, true);
  }

  // Compute global values
  reduceAll<int, size_t>(*comm_, Teuchos::REDUCE_SUM, 1,
                         &numLocalVertices_, &numGlobalVertices_);
  reduceAll<int, size_t>(*comm_, Teuchos::REDUCE_SUM, 1,
                         &numLocalEdges_, &numGlobalEdges_);

  env_->memory("After construction of graph model");
}

//////////////////////////////////////////////////////////////////////////

template <typename Adapter>
template <typename AdapterWithCoords>
void GraphModel<Adapter>::shared_GetVertexCoords(const AdapterWithCoords *ia)
{
  // get pointers to vertex coordinates from input adapter

  vCoordDim_ = ia->getDimension();

  if (vCoordDim_ > 0){
    input_t *coordInfo = new input_t [vCoordDim_];
    env_->localMemoryAssertion(__FILE__, __LINE__, vCoordDim_, coordInfo);

    for (int dim=0; dim < vCoordDim_; dim++){
      const scalar_t *coords=NULL;
      int stride=0;
      ia->getCoordinatesView(coords, stride, dim);
      ArrayRCP<const scalar_t> coordArray = arcp(coords, 0,
                                                 stride*numLocalVertices_,
                                                 false);
      coordInfo[dim] = input_t(coordArray, stride);
    }

    vCoords_ = arcp<input_t>(coordInfo, 0, vCoordDim_, true);
  }
}

//////////////////////////////////////////////////////////////////////////
  template <typename Adapter>
void GraphModel<Adapter>::print()
{
  if (env_->getDebugLevel() < VERBOSE_DETAILED_STATUS)
    return;

  std::ostream *os = env_->getDebugOStream();
  
  int me = comm_->getRank();
  std::string fn(" ");

  *os << me << fn
      << " Nvtx  " << gids_.size()
      << " Nedge " << edgeGids_.size()
      << " NVWgt " << numWeightsPerVertex_
      << " NEWgt " << nWeightsPerEdge_
      << " CDim  " << vCoordDim_
      << std::endl;

  for (lno_t i = 0; i < numLocalVertices; i++) {
    *os << me << fn << i << " GID " << gids_[i] << ": ";
    for (lno_t j = offsets_[i]; j < offsets_[i+1]; j++)
      *os << edgeGids_[j] << " " ;
    *os << std::endl;
  }

  if (comm_->getSize() > 1) {
    // Print local graph, with no off-process edges.
    ArrayView<const lno_t> localEdgeIds;
    ArrayView<const lno_t> localOffsets;
    ArrayView<input_t> localWgts;
    this->getLocalEdgeList(localEdgeIds, localOffsets, localWgts);

    for (lno_t i = 0; i < gids_.size(); i++) {
      *os << me << fn << i << " LGNO " << gids_[i] << ": ";
      for (lno_t j = localOffsets[i]; j < localOffsets[i+1]; j++) 
        *os << localEdgeIds[j] << " ";
      *os << std::endl;
    }
  }
  else
    *os << me << fn 
       << " LOCAL GRAPH IS SAME AS GLOBAL GRAPH ON ONE RANK " << std::endl;

  if (vCoordDim_) {
    for (lno_t i = 0; i < gids_.size(); i++) {
      *os << me << fn << i << " COORDS " << gids_[i] << ": ";
      for (int j = 0; j < vCoordDim_; j++)
         *os << vCoords_[j][i] << " ";
      *os << std::endl;
    }
  }
  else
    *os << me << fn << "NO COORDINATES AVAIL " << std::endl;
}

}   // namespace Zoltan2


#endif

